#! /usr/bin/env python
import os
import sys
from util import Colors
from gen_util import gen_decode, get_impl_end_token, get_impl_start_token, read_insts, gen_main, gen_modules
from info import Modules
from pathlib import Path

GEN_VERSION = "3"

OUTPUT_DIR = "./src/insts"

FILEPATH: str = Path(__file__).stem
DISCLAIMER = f"""// This file is auto-generated.
// Do not edit this file manually, use `{FILEPATH}.py` to regenerate it."""

DISCLAIMER_IMPL = f"""// This auto-generated file provides instruction set implementations.
// While you can customize the behavior, developers are strictly advised to
// modify only the `run` method in each instruction.
// Changes outside of these methods are not checked for compatibility and may be lost upon regeneration.
// Critical '$' comments must remain unaltered.
// Remember to back up this file frequently, as `{FILEPATH}.py` can overwrite it."""

MAIN_HEADER = f"""
// $GEN_VERSION {GEN_VERSION}
{DISCLAIMER}
#![allow(dead_code, unused_variables, unused_imports, unreachable_code, unused_mut)]
use crate::*;
use crate::bits::*;
use crate::format::*;
"""

MODULE_HEADER = f"""
// $GEN_VERSION {GEN_VERSION}
{DISCLAIMER_IMPL}
use crate::*;
"""

def is_compat_ver(str: str) -> bool:
    return str.startswith("// $GEN_VERSION") and str.split()[2] == GEN_VERSION

def assert_file_compat_ver(path: str):
    if not os.path.exists(path):
        raise FileNotFoundError(f"File {path} does not exist.")
    with open(path, "r") as f:
        lines = f.readlines()
        lines = [line.strip() for line in lines if line.strip()]
        if not lines or not is_compat_ver(lines[0]):
            raise ValueError(f"File {path} is not compatible with this generator version {GEN_VERSION}.")

def gen_main_file(modules: Modules):
    path = f"{OUTPUT_DIR}/mod.rs"
    # Validate destination module
    if os.path.exists(OUTPUT_DIR):
        try:
            assert_file_compat_ver(path)
        except ValueError as e:
            print(f"{Colors.FAIL}Error: {e}{Colors.ENDC}", file=sys.stderr)
            sys.exit(1)
    else:
        os.makedirs(OUTPUT_DIR)
    
    # Generate main file
    with open(path, "w") as f:
        f.write(MAIN_HEADER.strip() + "\n\n")
        f.write(gen_main(modules).strip())
        
    print(f"{Colors.OKGREEN}Generated {path}{Colors.ENDC}")
    return path
        
def gen_module_files(modules: Modules) -> list[str]:
    mouts = gen_modules(modules)
    paths: list[str] = list()
    for mod_name, inst_list in mouts.items():
        file_path = f"{OUTPUT_DIR}/{mod_name}.rs"
        if os.path.exists(file_path):
            try:
                assert_file_compat_ver(file_path)
            except ValueError as e:
                print(f"{Colors.FAIL}Error: {e}", file=sys.stderr)
                print(f"Skipping {file_path} due to compatibility issues.{Colors.ENDC}", file=sys.stderr)
                continue
        
        with open(file_path, "w") as f:
                f.write(MODULE_HEADER.strip() + "\n\n")
                for inst in inst_list.values():
                    f.write(inst + "\n\n")
        
        paths.append(file_path)
        print(f"{Colors.OKGREEN}Generated {len(inst_list)} insts in {file_path}{Colors.ENDC}")
        
    return paths

def read_impls(modules: Modules):
    for mod in modules.mods():
        mod_path = f"{OUTPUT_DIR}/{mod.file_name}.rs"
        if not os.path.exists(mod_path):
            continue
        
        try:
            assert_file_compat_ver(mod_path)
        except ValueError as e:
            print(f"{Colors.FAIL}Error: {e}, skipping {mod_path} due to compatibility issues.{Colors.ENDC}", file=sys.stderr)
            continue
        
        with open(mod_path, "r") as f:
            content = f.read()
        
        for inst in mod.insts:
            impl_start_tok = get_impl_start_token(inst)
            impl_end_tok = get_impl_end_token(inst)
            
            i = content.find(impl_start_tok)
            if i < 0:
                continue
            while i < len(content) and content[i] != '\n':
                i += 1
            i += 1 # move to the next line
            if i >= len(content):
                continue
            j = content.find(impl_end_tok, i)
            if j < i or j >= len(content) or j < 0: 
                print(f"{Colors.FAIL}Error: malformed impl tokens for inst {inst.raw_name}, skipping.{Colors.ENDC}", file=sys.stderr)
                continue
            
            impl = content[i:j].strip()
            inst.impl = impl
            
def gen_decode_file(modules: Modules):
    path = f"{OUTPUT_DIR}/decode.rs"
    # Validate destination module
    if os.path.exists(path):
        try:
            assert_file_compat_ver(path)
        except ValueError as e:
            print(f"{Colors.FAIL}Error: {e}{Colors.ENDC}", file=sys.stderr)
            sys.exit(1)
    
    # Generate decode file
    with open(path, "w") as f:
        f.write(MAIN_HEADER.strip() + "\n\n")
        f.write(gen_decode(modules).strip())
        
    print(f"{Colors.OKGREEN}Generated {path}{Colors.ENDC}")
    return path
     
if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: python {FILEPATH}.py <insts_file>")
        sys.exit(1)
    path = sys.argv[1]
    
    print(f"Generator version {GEN_VERSION}")
    modules = read_insts(path)
    
    fmt_paths: list[str] = []
    
    main_path = gen_main_file(modules)
    fmt_paths.append(main_path)
    
    decode_path = gen_decode_file(modules)
    fmt_paths.append(decode_path)
    
    read_impls(modules)
    module_paths = gen_module_files(modules)
    fmt_paths.extend(module_paths)
    
    
    fmt_cmd = f"rustfmt --config-path={OUTPUT_DIR}/../../rustfmt.toml " + " ".join(fmt_paths)
    print(f"running rustfmt: {fmt_cmd}")
    os.system(fmt_cmd)
    
    print(f"{Colors.OKGREEN}Generation completed successfully.{Colors.ENDC}")