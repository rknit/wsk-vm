#! /usr/bin/env python
import os
import sys
from util import Colors
from gen_util import get_impl_token, get_impl_token_full, read_insts, gen_main, gen_modules
from info import Modules
from pathlib import Path

GEN_VERSION = "1"

OUTPUT_DIR = "./src/insts"

FILEPATH: str = Path(__file__).stem
DISCLAIMER = f"""// This file is auto-generated.
// Do not edit this file manually, use `{FILEPATH}.py` to regenerate it."""

DISCLAIMER_IMPL = f"""// This file is auto-generated.
// This file contains the implementations of the instruction set, 
// which requires developers to implement them themselves.
// Please backup this file regularly, as it can be overwritten by `{FILEPATH}.py`."""

MAIN_HEADER = f"""
// $GEN_VERSION {GEN_VERSION}
{DISCLAIMER}
#![allow(dead_code, unused_variables, unused_imports, unreachable_code)]
use crate::{{VM, VMRunError, VMRunErrorKind}};
use crate::bits::*;
use crate::format::*;
"""

MODULE_HEADER = f"""
// $GEN_VERSION {GEN_VERSION}
{DISCLAIMER_IMPL}
use crate::{{VM, VMRunError}};
"""

def is_compat_ver(str: str) -> bool:
    return str.startswith("// $GEN_VERSION") and str.split()[2] == GEN_VERSION

def assert_file_compat_ver(path: str):
    if not os.path.exists(path):
        raise FileNotFoundError(f"File {path} does not exist.")
    with open(path, "r") as f:
        lines = f.readlines()
        lines = [line.strip() for line in lines if line.strip()]
        if not lines or not is_compat_ver(lines[0]):
            raise ValueError(f"File {path} is not compatible with this generator version {GEN_VERSION}.")

def gen_main_file(modules: Modules):
    path = f"{OUTPUT_DIR}/mod.rs"
    # Validate destination module
    if os.path.exists(OUTPUT_DIR):
        try:
            assert_file_compat_ver(path)
        except ValueError as e:
            print(f"{Colors.FAIL}Error: {e}{Colors.ENDC}", file=sys.stderr)
            sys.exit(1)
    else:
        os.makedirs(OUTPUT_DIR)
    
    # Generate main file
    with open(path, "w") as f:
        f.write(MAIN_HEADER.strip() + "\n\n")
        f.write(gen_main(modules).strip())
        
    print(f"{Colors.OKGREEN}Generated {path}{Colors.ENDC}")
    return path
        
def gen_module_files(modules: Modules) -> list[str]:
    mouts = gen_modules(modules)
    paths: list[str] = list()
    for mod_name, inst_list in mouts.items():
        file_path = f"{OUTPUT_DIR}/{mod_name}.rs"
        if os.path.exists(file_path):
            try:
                assert_file_compat_ver(file_path)
            except ValueError as e:
                print(f"{Colors.FAIL}Error: {e}", file=sys.stderr)
                print(f"Skipping {file_path} due to compatibility issues.{Colors.ENDC}", file=sys.stderr)
                continue
        else:
            with open(file_path, "w") as f:
                f.write(MODULE_HEADER.strip() + "\n\n")
        
        # read file to string to check if there are any instruction that is already implemented
        append_insts: list[str] = list()
        with open(file_path, "r") as f:
            existing_content = f.read()
            for inst, gen_str in inst_list.items():
                token = get_impl_token_full(inst)
                if token in existing_content:
                    continue
                token = get_impl_token(inst)
                if token in existing_content:
                    print(f"{Colors.WARNING}Warning: '{inst.name}' is already \
                          implemented with format '{inst.format}' in {file_path}, skipping.{Colors.ENDC}")
                    continue
                append_insts.append(gen_str)
        
        # append new instructions to the file
        with open(file_path, "a") as f:
            for inst in append_insts:
                f.write(inst + "\n")
                
        paths.append(file_path)
        print(f"{Colors.OKGREEN}Generated {len(append_insts)} new instructions in {file_path}{Colors.ENDC}")
        
    return paths
     
if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: python {FILEPATH}.py <insts_file>")
        sys.exit(1)
    path = sys.argv[1]
    
    print(f"Generator version {GEN_VERSION}")
    modules = read_insts(path)
    main_path = gen_main_file(modules)
    module_paths = gen_module_files(modules)
    
    
    fmt_cmd = f"rustfmt --config-path={OUTPUT_DIR}/../../rustfmt.toml " + main_path + " " + " ".join(module_paths)
    print(f"running rustfmt: {fmt_cmd}")
    os.system(fmt_cmd)
    
    print(f"{Colors.OKGREEN}Generation completed successfully.{Colors.ENDC}")