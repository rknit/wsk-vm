// $GEN_VERSION 1
// This file is auto-generated.
// Do not edit this file manually, use `gen_inst.py` to regenerate it.
#![allow(dead_code, unused_variables, unused_imports, unreachable_code)]
use crate::bits::*;
use crate::format::*;
use crate::{VM, VMRunError, VMRunErrorKind};

mod rv32i_rv64i;
use rv32i_rv64i::*;

mod rv64i;
use rv64i::*;

#[derive(Debug, Clone, Copy)]
pub enum Inst {
    // RV32I_RV64I
    Add { rd: u8, rs1: u8, rs2: u8 },
    Addi { rd: u8, rs1: u8, imm: i64 },
    Sb { rs1: u8, rs2: u8, offset: i64 },
    Beq { rs1: u8, rs2: u8, offset: i64 },
    Lui { rd: u8, imm: i64 },
    Jal { rd: u8, offset: i64 },
    Ecall {},

    // RV64I
    Addiw { rd: u8, rs1: u8, imm: i64 },
}

impl Inst {
    pub fn decode(fmt: RawFormat) -> Option<Self> {
        use RawFormat::*;
        Some(match fmt {
            R {
                opc,
                funct3,
                funct7,
                rd,
                rs1,
                rs2,
            } => match (opc, funct3, funct7) {
                (0b01100, 0b000, 0b0000000) => Inst::Add { rd, rs1, rs2 },

                #[allow(unreachable_patterns)]
                _ => return None,
            },
            I {
                opc,
                funct3,
                rd,
                rs1,
                imm,
            } => match (opc, funct3) {
                (0b00100, 0b000) => Inst::Addi {
                    rd,
                    rs1,
                    imm: sext(imm as u64, 11) as i64,
                },
                (0b00110, 0b000) => Inst::Addiw {
                    rd,
                    rs1,
                    imm: sext(imm as u64, 11) as i64,
                },

                #[allow(unreachable_patterns)]
                _ => return None,
            },
            S {
                opc,
                funct3,
                rs1,
                rs2,
                imm,
            } => match (opc, funct3) {
                (0b01000, 0b000) => Inst::Sb {
                    rs1,
                    rs2,
                    offset: sext(imm as u64, 11) as i64,
                },

                #[allow(unreachable_patterns)]
                _ => return None,
            },
            B {
                opc,
                funct3,
                rs1,
                rs2,
                imm,
            } => match (opc, funct3) {
                (0b11000, 0b000) => Inst::Beq {
                    rs1,
                    rs2,
                    offset: sext((imm as u64) << 1, 12) as i64,
                },

                #[allow(unreachable_patterns)]
                _ => return None,
            },
            U { opc, rd, imm } => match opc {
                0b01101 => Inst::Lui {
                    rd,
                    imm: ((imm as i32) << 12) as i64,
                },

                #[allow(unreachable_patterns)]
                _ => return None,
            },
            J { opc, rd, imm } => match opc {
                0b11001 => Inst::Jal {
                    rd,
                    offset: sext((imm as u64) << 1, 20) as i64,
                },

                #[allow(unreachable_patterns)]
                _ => return None,
            },
            Other { opc } => match opc {
                0b11100 => Inst::Ecall {},

                #[allow(unreachable_patterns)]
                _ => return None,
            },
        })
    }

    pub fn run(self, vm: &mut VM) -> Result<(), VMRunError> {
        match self {
            Inst::Add { rd, rs1, rs2 } => Add::run(vm, rd, vm.x(rs1), vm.x(rs2)),
            Inst::Addi { rd, rs1, imm } => Addi::run(vm, rd, vm.x(rs1), imm),
            Inst::Sb { rs1, rs2, offset } => Sb::run(vm, vm.x(rs1), vm.x(rs2), offset),
            Inst::Beq { rs1, rs2, offset } => Beq::run(vm, vm.x(rs1), vm.x(rs2), offset),
            Inst::Lui { rd, imm } => Lui::run(vm, rd, imm),
            Inst::Jal { rd, offset } => Jal::run(vm, rd, offset),
            Inst::Ecall {} => Ecall::run(vm),
            Inst::Addiw { rd, rs1, imm } => Addiw::run(vm, rd, vm.x(rs1), imm),

            #[allow(unreachable_patterns)]
            _ => {
                return Err(VMRunError {
                    err_addr: vm.pc,
                    kind: VMRunErrorKind::Other(format!("{:?}", self)),
                    info: "unimplemented inst",
                });
            }
        }
    }
}
